#include "multi_lookup.h"

void* request(void* sts)
{
    // local struct for access to sts
    synchro_thread_struct* s = (synchro_thread_struct*) sts;

    // local int value to act as counter for files processed sucessfully
    int count = 0;
    // int processed_files = s->ops;
    // printf("%d\n", processed_files);
    // int as = size(s->fileNames);
    while(s->start < s->argvnum)
    // for (int i = 0; i < s->argvnum; i++)
    {       
        // protect filename location
        pthread_mutex_lock(s->req_lock);

        char *fn = s->fileNames[s->start];
        count++;
        s->start++;
        pthread_mutex_unlock(s->req_lock);

        // open file
        FILE* f = fopen(fn, "r");
        if (f != NULL)
        {
            
            // s->start++;
            // pthread_mutex_unlock(s->shared_buffer);
            // pthread_mutex_lock(s->shared_buffer);
            char line[MAX_DOMAIN_NAME_LENGTH];
            // printf("entered while\n");
            // read line by line implementation
            

            // pthread_mutex_unlock(s->shared_buffer);

            while(fgets(line,MAX_DOMAIN_NAME_LENGTH, f) != NULL)
            {
                // fprintf(s->serviced,"%s\n", strtok(line,"\n"));
                array_put(s->buff, strtok(line,"\n"));
                // unlock shared buffer
            }
            
            // close previously opened file, free memory for char file
            fclose(f);

        }
        
    }
    // pthread_mutex_lock(s->req_lock);

    //printf("numreq = %d\n", s->numreq);     
    

    
    // pthread_mutex_unlock(s->req_lock);
    // post for loop ops, reporting thread service and number of files serviced
    // printf("request complete\n");
    
    // create if doesn't exist
    // FILE* log = s->serviced;
    // https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm
    // fprintf(stdout,"Thread %ld serviced %d files.\n", syscall(SYS_gettid), count);

    // counts down number of requesters untill all requesters are finished
    if (s->numreq > 1)
    {
        // pthread_mutex_lock(s->tcount);
        s->numreq = s->numreq-1;
        // printf("numreq = %d\n", s->numreq);
        // pthread_mutex_unlock(s->file_queue);

    }
    // in the event that all requesters are finished, pull number of resolves and add poison pills relative 
    // to that number through the while loop. 
    else
    {
        int num = s->numres;
        // printf("%d\n", num);
        while(num > 0)
        {
            array_put(s->buff, "####");
            num--;
        }
    }

    pthread_mutex_lock(s->res_lock);

    fprintf(stdout,"Thread %ld serviced %d files.\n", syscall(SYS_gettid), count);

    pthread_mutex_unlock(s->res_lock);
    

    // printf("request complete\n");

    return 0;
}

void* resolve(void* sts)
{

    // local struct for access to sts
    synchro_thread_struct* s = (synchro_thread_struct*) sts;
    
    // mallocced a char var for ip address generated by dnsLookup
    char* ip_add = malloc(MAX_IP_LENGTH);
    char* domain_name = (char*) malloc(MAX_DOMAIN_NAME_LENGTH);
    int count = 0;
    // int hot;
    // for (int i = 0; i < size(s->fileNames); i++)
    while(strcmp(domain_name,"####") != 0)
    {
        
        // printf("%ld entered resolve while\n", syscall(SYS_gettid));
        // lock for queue array_get op
        // pthread_mutex_lock(s->shared_buffer);
        
        // char value to store strcpy-ed domain_name from shared buffer queue using array_get
        
        array_get(s->buff, &domain_name);

        if (strcmp(domain_name,"####") == 0)
        {
            break;
        }

        
        // printf("entered resolve if\n");

        // check for dnsLookup op success, different outcome if failure to find ip
        // *domain_name = &**domain_name 
        int u = dnslookup(domain_name, ip_add, MAX_IP_LENGTH);
        if(!u)
        {
            pthread_mutex_lock(s->res_lock);
            // upon success, report domain name and ip address to log
            count++;
            // fopen(s->resolved, "ab+");
            // https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm
            fprintf(s->resolved,"%s, %s\n", domain_name, ip_add);
            // fclose(s->resolved);

            pthread_mutex_unlock(s->res_lock);

        }
        else
        {
            // upon sucess, report domain name and ip address to log
            pthread_mutex_lock(s->res_lock);
            count++;
            // fopen(s->resolved, "ab+");
            // https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm
            // fprintf expectation: "glsdkjf.com, NOT_RESOLVED"
            fprintf(s->resolved,"%s, NOT_RESOLVED\n", domain_name);
            // fclose(s->resolved);

            pthread_mutex_unlock(s->res_lock);

        } 

        
        
    }

    pthread_mutex_lock(s->res_lock);
    // create if doesn't exist
    // FILE* log = s->serviced;
    // https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm
    fprintf(stdout,"Thread %ld resolved %d files.\n", syscall(SYS_gettid), count);

    pthread_mutex_unlock(s->res_lock);
    // printf("exit resolve while\n");
    free(domain_name);
    free(ip_add);
    return 0; 
    
}

int main(int argc, char* argv[])
{
    // start the timer
    // https://linuxhint.com/gettimeofday_c_language/

    struct timeval start,stop;
    gettimeofday(&start, NULL);

    // expected arguments : ./multi-lookup 5 5 serviced.txt resolved.txt input/names*.txt

    // check if # of arguements is correct, terminates without prejudice if either  

    if (argc <= 5 || argc > 5 + MAX_INPUT_FILES)
    {
        fprintf(stderr, "%d Arguements too many or too few, exiting program\n", argc);
        exit(1);
    }

     // check if argv values for resolver and requester are <= 10, arbitrary which defined value is used

    int res,req;
    req = atoi(argv[1]); 
    res = atoi(argv[2]);
    

    if ((res > MAX_RESOLVER_THREADS) || (res < MIN_R_THREADS))
    {
        fprintf(stderr,"%d Res thread value invalid, threads > 10 or < 1. exiting program\n",res);
        exit(1);
    }
    
    if ((req > MAX_REQUESTER_THREADS) || (req < MIN_R_THREADS))
    {
        fprintf(stderr, "%d Req thread value invalid, threads > 10 or < 1. exiting program\n",req);
        exit(1);
    }

    // TODO: initialize struct for req, res using the defined struct

    synchro_thread_struct sts;
    // char* fileN[argc - 5];

    // for (int i = 0; i< MAX_INPUT_FILES; i++)
    // {
    //     sts.fileNames[i] = malloc(MAX_NAME_LENGTH);
    // }

    // add argv text file values to fileNames array
    // start at 5 for first text file name arguement, end at last arguement (min 5, max 5-argc)
    int valid = 0;
    // static array
    for (int i = 5; i < argc; i++)
    {
        if (access(argv[i],F_OK) == 0)
        {
            // check this
            sts.fileNames[valid] = argv[i];
            valid++;
        }
    }

    if (valid < 1)
    {
        // array_free
        fprintf(stderr, "No valid input files specified\n");
        exit(1);

    }
    // TODO: initialize the shared buffer

    array shared;
    array_init(&shared);

    pthread_mutex_t shared_buffer; // mutex for shared buffer
    pthread_mutex_t file_queue;    // mutex for file queue (already implemented, possibly redundant) 
    pthread_mutex_t req_lock;      // mutex for writing to req_log
    pthread_mutex_t res_lock;      // mutex for writing to res_log
    //pthread_mutex_t tcount;

    pthread_mutex_init(&shared_buffer, NULL);
    pthread_mutex_init(&file_queue, NULL);
    pthread_mutex_init(&req_lock, NULL);
    pthread_mutex_init(&res_lock, NULL);
    //pthread_mutex_init(&tcount, NULL);
    
    sts.argvnum = argc - 5;
    sts.numres = res;
    sts.numreq = req;
    sts.start = 0;
    // sts.fileNames = &fileN;
    sts.serviced = fopen(argv[3], "w");
    sts.resolved = fopen(argv[4], "w");
    sts.buff = &shared;
    sts.file_queue = &file_queue;
    sts.shared_buffer = &shared_buffer;
    // sts.tcount = &tcount;
    sts.req_lock = &req_lock;
    sts.res_lock = &res_lock; 

    // printf("shared buffer\n");

    // TODO: create threads based on input values using create, then join based on res 
    // creation based on this: https://diveintosystems.org/book/C14-SharedMemory/posix.html

    // create two thread arrays, size determined by previous argv 0 and 1 vals
    pthread_t reqthread[req];
    pthread_t resthread[res];

    for (int i = 0; i < req; i++)
    {
        pthread_create(&reqthread[i], NULL, request, &sts);
    }

    for (int i = 0; i < res; i++)
    {
        pthread_create(&resthread[i], NULL, resolve, &sts);
    }

    // printf("created threads\n");

    // for(int i = 0; i < req; i++)
    // {
    //     array_put(&fileN, "####");
    // }
    // for(int i = 0; i < res; i++)
    // {
    //     
    // }

    //requester threads first
    for (int i = 0; i < req; i++)
    {
        pthread_join(reqthread[i], NULL);
    }


    // call array-put = resolvers, push into shared buffer

    for (int i = 0; i < res; i++)
    {
        // array_put(&shared, "####");
        pthread_join(resthread[i], NULL);
        
        // printf("poison put\n");
    }

    // printf("joined\n");

    // TODO: close log files and free data queues

    fclose(sts.serviced);
    fclose(sts.resolved);
    array_free(&shared);
    // for (int i = 0; i< MAX_INPUT_FILES; i++)
    // {
    //     free(sts.fileNames[i]);
    // }
    // free(sts.fileNames);
    pthread_mutex_destroy(&shared_buffer);
    pthread_mutex_destroy(&file_queue);
    pthread_mutex_destroy(&req_lock);
    pthread_mutex_destroy(&res_lock);
    // pthread_mutex_destroy(&tcount);

    // TODO: Finish timing and print results to console 
    // https://stackoverflow.com/questions/2125219/how-to-get-the-running-of-time-of-my-program-with-gettimeofday
    gettimeofday(&stop, NULL);
    double elapsed = (stop.tv_sec - start.tv_sec) + 
              ((stop.tv_usec - start.tv_usec)/1000000.0);
    printf("Total Run Time: %f seconds\n",elapsed);
    return 0;
}